var tipuesearch = {"pages": [{'title': 'About', 'text': '成員： \n 40823110 repo \xa0|\xa0 40823110 web \xa0 | \n 40823125 repo \xa0 |  40823125 web   | \n 40823117 repo \xa0 |  40823117 web   | \xa0 \xa0 \n 40823122 repo \xa0 |  40823122 web   | \xa0 \xa0 \n 40823129 repo \xa0 |  40823129 web   |   \xa0 \n 40823149 repo \xa0 |  40823149 web   | \xa0 \xa0 \n 40823152 repo \xa0|\xa0 40823152 web \xa0| \n 40823153 repo \xa0 |  40823153 web \xa0 | \n 小組： \n 40823110 repo \xa0|\xa0 40823110 web \xa0 | \n 40823125 repo \xa0 |  40823125 web \xa0 | \n 40823117 repo   |  40823117 web   | \n 40823122 repo   |  40823122 web   | \n 40823129 repo   |  40823129 web   | \n 40823149 repo   |  40823149 web   | \n 40823152 repo \xa0|\xa0 40823152 web \xa0| \n 40823153 repo \xa0 |  40823153 web  | \n \n gitlab repo | gitlab web \n \n gogs : \n stage3-ag6 repo \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'Collaborative flowchart', 'text': '我認為藉由此流程圖可以降低內容互相覆蓋，最終造成無法辨識是誰更改內容的情況。 \n 每一位協同者製作與更改的項目都會顯示在上面，還能輕易地找出之前所做的每一項目和誰有在做事。 \n \n', 'tags': '', 'url': 'Collaborative flowchart.html'}, {'title': 'stage1', 'text': '', 'tags': '', 'url': 'stage1.html'}, {'title': 'stage1-ag7', 'text': '成員： \n 40823129 回購 \xa0|\xa0 40823129網站 \xa0| \n 40823149 回購 \xa0 |  40823149網站 | \xa0 \xa0 \n \n       \n   \n \n \n <<<<<<< 頭', 'tags': '', 'url': 'stage1-ag7.html'}, {'title': 'stage1-ag14', 'text': '網頁表現： \n stage1-ag14 repo |  stage1-ag14 web | \n 成員： \n 40823110 repo \xa0 |  40823110 web | \xa0 \xa0 \n 40823125 repo \xa0|\xa0 40823125 web \xa0| \n 40823132 repo \xa0|\xa0 40823132 web \xa0|', 'tags': '', 'url': 'stage1-ag14.html'}, {'title': 'stage1-ag13', 'text': '\n 組員： \n 40823117 潘奕丞 \n 艾： https  :  //github.com/40823117  /cd2021 \n 網頁： https  :  //40823117.github.io/cd2021/ \n 40823122 吳家凱 \n 艾： https  :  //github.com/40823122/cd2021 \n 網頁： https  :  //40823122.github.io/cd2021/ \n \n 協同修改 \n \n \n \n \n \n \n \n \n \n \n \n \n 訂貨檔： https  ://drive.google.com/drive/folders/1Gw2DKXEOqffqAUVHs4KAM4dbICA-9G0r  ?  usp  =  sharing \n v-rep模擬 \n 模擬檔 \n 第1次模擬 \n \n 啟動的發現神器的槽的時候神深導致運動不完全 \n \n 第2次模擬 \n \n 啟動後發現在INVENTOR畫出來跟V-REP模擬出來的有仇 \n INVENTOR畫出來的圓是真圓，但REP模擬出來是貼上的，這和上那些面的完全合導致 配合上有問題。 \n 所以不想修改任何一個圓圓的孩子，還有增加一些面子之間的小動作，再進行模擬。 \n 第3次模擬 \n \n 修改完之後。 \n 可以發現在選轉上有明顯的優化。 \n 但是因為增加了搖晃，讓她產生了動，導致運動的目的不理想，無法實現需要的運動。 \n 第4次模擬 \n \n 觀察了第三次模擬 \n 決定嬰兒在奶牛的槽口加上倒角來修改晃動所產生的誤差。 \n 模擬結果確定了倒角能夠解決晃動產生的偏差。 \n 第5次模擬(最終版) \n \n 修改完全部問題後，加入了球體模擬被分類的貨物。 \n', 'tags': '', 'url': 'stage1-ag13.html'}, {'title': 'stage2', 'text': '', 'tags': '', 'url': 'stage2.html'}, {'title': '階段2-ag7', 'text': '成員： \n 40823129 回購 \xa0|\xa0 40823129網站 \xa0| \n 40823149 回購 \xa0 |  40823149網站 | \xa0 \xa0 \n 40823117 回購\xa0 |\xa0 40823117網站 \xa0| \n 40823122 回購 \xa0 |  40823122網站 | \xa0 \xa0 \n \n \n \n \n', 'tags': '', 'url': '階段2-ag7.html'}, {'title': 'stage2-ag12', 'text': 'stage2-ag12 repo   |  stage2-ag12 web   | \n 組員 \n \xa0 40823152 repo \xa0 |  \xa0 40823152 web \xa0 | \n \xa0 40823153 repo \xa0 |  \xa0 40823153 web \xa0 | \n \xa0 40823125 repo \xa0 |  \xa0 40823125 web \xa0 | \n \xa0 40823110 repo \xa0 |  \xa0 40823110 web \xa0|', 'tags': '', 'url': 'stage2-ag12.html'}, {'title': 'stage3', 'text': '組長： 40823152 repo  \xa0|\xa0 40823152 web \xa0| \n 組員： \n 40823110 repo \xa0|\xa0 40823110 web \xa0 | \n 40823125 repo \xa0 |  \xa0 40823125 web \xa0 | \n 40823153 repo \xa0 |  \xa0 40823153 web \xa0 | \n 40823117 repo \xa0 |  40823117 web | \xa0 \xa0 \n 40823122 repo \xa0 |  40823122 web | \xa0 \xa0 \n 40823129 repo \xa0 |  40823129 web | \xa0 \xa0 \n 40823149 repo \xa0 |  40823149 web | \xa0 \xa0', 'tags': '', 'url': 'stage3.html'}, {'title': '任務1', 'text': '', 'tags': '', 'url': '任務1.html'}, {'title': '40823125-1', 'text': '任務一教學 \n', 'tags': '', 'url': '40823125-1.html'}, {'title': '40823152-1', 'text': '\n task 1 教學 \n 教學影片: \n \n \n 快速操作: \n 1.擁有這2個檔案 \n \n 2.把print(group)改成 \n  print(\'<p>\'+group[0]+\' | <a href="https://\'+group[1]+\'.github.io/\'+group[0]+\'">網站</a> | <a href="https://github.com/\'+group[1]+\'/\'+group[0]+\'">倉儲</a></p>\')\n#印出:字串group[第1項]+httpps://+group[第2項]+.github.io/+group[第1項]+網站|:https//github.com/+group[第2項]+/+group[第1項]+倉儲 \n \n 3. \n for j in range(2,17,2):#設j迴圈的範圍(第3項到第16項的範圍，每次+2)\n print(\'<p>\'+group[j]+\'|Website:\'+\'<a href="https://\'+group[j]+\'.github.io/cd2021\'+\'">\'+group[j]+\'</a>\'+\'|Repository:\'+\'<a href="https://github.com/\'+group[j]+\'/cd2021\'+\'">\'+group[j]+\'</a></p>\')\n #印出:字串group[第3項]+|Website:httpps://+group[第3項]+.github.io/cd2021+group[第3項] + |Repository:https//github.com/+group[第3項]+/+group[第3項]+group[第3項]\n   \n \n 4.將學號改正 \n    data = [a.replace(\'4823122\',\'40823122\') for a in data]#將data中4823122改成40823122 \n \n 5. \n data = [c.replace(\'\\t\\t\\t\\t\',\'\') for c in data]#打data中第3組後面4個\\t改成空白 \n \n 6. \n  try:#try...except 可跳過讀取不到的資料\n            print(\'<p>\'+group[j]+\'|Website:\'+\'<a href="https://\'+group[j]+\'.github.io/cd2021\'+\'">\'+group[j]+\'</a>\'+\'|Repository:\'+\'<a href="https://github.com/\'+group[j]+\'/cd2021\'+\'">\'+group[j]+\'</a></p>\')   \n            #印出:字串group[第3項]+|Website:httpps://+group[第3項]+.github.io/cd2021+group[第3項] + |Repository:https//github.com/+group[第3項]+/+group[第3項]+group[第3項]\n        except:\n            continue#需要返回迴圈 \n \n 7. \n data = [b.replace(\'_\',\'-\') for b in data]#把_改成- \n \n 8.完成 \n \n 結果: \n stage3-ag1 | \xa0 網站 \xa0 | \xa0 倉儲 \n 40823131|Website: 40823131 |Repository: 40823131 \n a40823112|Website: a40823112 |Repository: a40823112 \n 40823123|Website: 40823123 |Repository: 40823123 \n 40823145|Website: 40823145 |Repository: 40823145 \n 40823136|Website: 40823136 |Repository: 40823136 \n 40823109|Website: 40823109 |Repository: 40823109 \n 40823116|Website: 40823116 |Repository: 40823116 \n 40823108|Website: 40823108 |Repository: 40823108 \n stage3-ag2 | \xa0 網站 \xa0 | \xa0 倉儲 \n 40823151|Website: 40823151 |Repository: 40823151 \n 40623121|Website: 40623121 |Repository: 40623121 \n 40871106|Website: 40871106 |Repository: 40871106 \n 40823102|Website: 40823102 |Repository: 40823102 \n 40823104|Website: 40823104 |Repository: 40823104 \n 40823106|Website: 40823106 |Repository: 40823106 \n 40823101|Website: 40823101 |Repository: 40823101 \n 40823132|Website: 40823132 |Repository: 40823132 \n stage3-ag3 | \xa0 網站 \xa0 | \xa0 倉儲 \n 40823119|Website: 40823119 |Repository: 40823119 \n 40823150|Website: 40823150 |Repository: 40823150 \n 40823103|Website: 40823103 |Repository: 40823103 \n 40823107|Website: 40823107 |Repository: 40823107 \n 40523252|Website: 40523252 |Repository: 40523252 \n 40823154|Website: 40823154 |Repository: 40823154 \n stage3-ag4 | \xa0 網站 \xa0 | \xa0 倉儲 \n 40823142|Website: 40823142 |Repository: 40823142 \n 40823144|Website: 40823144 |Repository: 40823144 \n 40823127|Website: 40823127 |Repository: 40823127 \n 40823148|Website: 40823148 |Repository: 40823148 \n 40823121|Website: 40823121 |Repository: 40823121 \n 40823135|Website: 40823135 |Repository: 40823135 \n 40823114|Website: 40823114 |Repository: 40823114 \n 40823146|Website: 40823146 |Repository: 40823146 \n stage3-ag5 | \xa0 網站 \xa0 | \xa0 倉儲 \n 40823111|Website: 40823111 |Repository: 40823111 \n 40823115|Website: 40823115 |Repository: 40823115 \n 40823128|Website: 40823128 |Repository: 40823128 \n 40823120|Website: 40823120 |Repository: 40823120 \n 40823140|Website: 40823140 |Repository: 40823140 \n 40823124|Website: 40823124 |Repository: 40823124 \n 40823139|Website: 40823139 |Repository: 40823139 \n 40823126|Website: 40823126 |Repository: 40823126 \n stage3-ag6 | \xa0 網站 \xa0 | \xa0 倉儲 \n 40823152|Website: 40823152 |Repository: 40823152 \n 40823110|Website: 40823110 |Repository: 40823110 \n 40823122|Website: 40823122 |Repository: 40823122 \n 40823125|Website: 40823125 |Repository: 40823125 \n 40823117|Website: 40823117 |Repository: 40823117 \n 40823129|Website: 40823129 |Repository: 40823129 \n 40823149|Website: 40823149 |Repository: 40823149 \n 40823153|Website: 40823153 |Repository: 40823153', 'tags': '', 'url': '40823152-1.html'}, {'title': '任務 2', 'text': '', 'tags': '', 'url': '任務 2.html'}, {'title': '40823149', 'text': '下載coppeliasim 4.2.0 版本\xa0 4.2.0 版 。 \n \n 下載\xa0 http://mde.tw/cad2020/downloads/coppeliasim/vrep_remoteapi_ex.7z \xa0 \n \n 將remoteApi.dll / sim.py /simComst.py 複製島泡泡數據夾中間 \n \n 將 bubblerote_remoteApi.py 拉進小白框在一起 \n \n 修改內容 { 將import vrep修改為import sim as vrep} \n \n 在小白框按工具/去 \n 在進入coppeliasim叫出小車進行操作 \n \n \n', 'tags': '', 'url': '40823149.html'}, {'title': '40823125-2', 'text': '任務二教學', 'tags': '', 'url': '40823125-2.html'}, {'title': '40823152-2', 'text': 'stage2-ag12 python keyboard \n 使用python keyboard 來操控投籃機 \n \n \n \n \n 程式碼: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n \n \n \n import   sim as vrep \n import   sys \n import   keyboard \n # child threaded script:  \n #simExtRemoteApiStart(19999) \n \xa0 \xa0 \n vrep.simxFinish( - 1 ) \n \xa0 \xa0 \n clientID  =   vrep.simxStart( \'127.0.0.1\' ,  19999 ,  True ,  True ,  5000 ,  5 ) \n errorCode,left_motor_handle = vrep.simxGetObjectHandle(clientID, \'Revolute_joint\' ,vrep.simx_opmode_oneshot_wait) \n \xa0 \n if   clientID! =   - 1 : \n \xa0\xa0\xa0\xa0 print ( "Connected to remote server" ) \n \xa0\xa0\xa0\xa0 while   True : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 try : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   keyboard.is_pressed( \'up\' ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetVelocity(clientID,left_motor_handle, - 16 , vrep.simx_opmode_oneshot_wait) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( \'up \' )  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   keyboard.is_pressed( \'down\' ):\xa0\xa0\xa0\xa0  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetVelocity(clientID,left_motor_handle, 1 , vrep.simx_opmode_oneshot_wait) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( \'down\' ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   keyboard.is_pressed( \'space\' ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetVelocity(clientID,left_motor_handle, 0 , vrep.simx_opmode_oneshot_wait) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( \'space\' ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pass \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 except : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 break \n else :  \n \xa0\xa0\xa0\xa0 print ( \'Connection not successful\' ) \n \xa0\xa0\xa0\xa0 sys.exit( \'Could not connect\' ) \n \xa0 \xa0 \n \xa0 \xa0 \n \xa0\xa0 \xa0 \n \xa0 \xa0 \n if   errorCode  = =   - 1 :\xa0  \n \xa0\xa0\xa0\xa0 print ( \'Can not find left or right motor\' ) \n \xa0\xa0\xa0\xa0 sys.exit() \n \n \n \n \n \n \n \n \n 參考網址 \n \n \n \n \n \n \n 1 \n 2 \n \n \n \n #需要: \n pip3 install keyboard \n \n \n \n \n \n \n \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n \n \n \n import   keyboard\xa0  # using module keyboard \n while   True :\xa0  # making a loop \n \xa0\xa0\xa0\xa0 try :\xa0  # used try so that if user pressed other than the given key error will not be shown \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   keyboard.is_pressed( \'q\' ):\xa0  # if key \'q\' is pressed  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( \'You Pressed A Key!\' ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 break \xa0  # finishing the loop \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pass \n \xa0\xa0\xa0\xa0 except : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 break \xa0  # if user pressed a key other than the given key the loop will break \n \n \n \n \n \n \n', 'tags': '', 'url': '40823152-2.html'}, {'title': 'w16-exam', 'text': '', 'tags': '', 'url': 'w16-exam.html'}, {'title': '40823125', 'text': 'MTB Onshape \n 建立 CoppeliaSim 4.1.0 MTB robot 場景 \n 手臂末端加入 components-gripper-suction pad 吸盤 \n 逆向運動學函式 \n Python remote API 逆向運動學函式', 'tags': '', 'url': '40823125.html'}, {'title': '40823122', 'text': '成果連結 \n', 'tags': '', 'url': '40823122.html'}, {'title': '40823152', 'text': 'MTB_robot onshape \n onshape \n \n stl \n 直接使用coppeliasim的MTB_robot的ttt檔轉成stl檔後放進onshape裡，照著原本的尺寸畫上去。 \n \n \n \n \n \n onshape \n onshape教學 \n \n \n \n MTB_robot coppeliasim \n W16_exam.7z \n 使用老師w15的鍵盤控制，使自己組裝完的MTB_robot可以鍵盤控制。 \n \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n \n \n \n function   sysCall_init() \n \xa0\xa0\xa0\xa0 -- do some initialization here \n \xa0\xa0\xa0\xa0\xa0 axis1=sim.getObjectHandle( \'MTB_axis1\' ) \n \xa0\xa0\xa0\xa0\xa0 axis1=sim.getObjectHandle( \'MTB_axis1\' ) \n \xa0\xa0\xa0\xa0\xa0 axis3=sim.getObjectHandle( \'MTB_axis3\' ) \n \xa0\xa0\xa0\xa0\xa0 axis4=sim.getObjectHandle( \'MTB_axis4\' )\xa0\xa0\xa0\xa0  \n \xa0\xa0\xa0\xa0\xa0 rotation1 = 0 \n \xa0\xa0\xa0\xa0\xa0 distance3 = 0 \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0 deg =  math.pi /180 \n \xa0\xa0\xa0\xa0\xa0 --sim.sJointTargetVelocity(joint,5.5) \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0 \n end \n \xa0 \n function   sysCall_actuation() \n \xa0 calibration = 0.0042 \n \xa0 message,auxiliaryData=sim.getSimulatorMessage() \n \xa0 if   (message==sim.message_keypress)  then \n \xa0\xa0\xa0\xa0\xa0\xa0 print (auxiliaryData[1]) --key \n \xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]== string.byte ( \' \' ))  then \n \xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==97)  then --a \n \xa0\xa0\xa0\xa0\xa0\xa0 rotation1 = rotation1 + 5*deg \n \xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis1, rotation1) \n \xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==100)  then   --d \n \xa0\xa0\xa0\xa0\xa0\xa0 rotation1 = rotation1 - 5*deg \n \xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis1, rotation1) \n \xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==119)  then   --s \n \xa0\xa0\xa0\xa0\xa0\xa0 distance3 = distance3 + 0.01 + calibration \n \xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis3, distance3) \n \xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==115)  then   --w \n \xa0\xa0\xa0\xa0\xa0\xa0 distance3 = distance3 - 0.01 - calibration \n \xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis3, distance3) \n \xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0 end \xa0\xa0\xa0 \n \xa0 \n \xa0 \n end \n function   sysCall_sensing() \n \xa0\xa0\xa0\xa0 -- put your sensing code here \n end \n \xa0 \n function   sysCall_cleanup() \n \xa0\xa0\xa0\xa0 -- do some clean-up here \n end \n \xa0 \n -- See the user manual or the available code snippets for additional callback functions and details \n \n \n \n \n \n \n \n \n \n \n MTB_robot組裝教學: \n w16_t.7zip \n \n \n 參考影片: \n \n \n MTB_robot add suction pad \n 在coppeliaSim裡的MTB_robot增加吸盤控制。(使用老師的程式) \n W16_exam.7z \n \n 主程式 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n \n \n \n function   sysCall_init() \n \xa0\xa0\xa0\xa0 -- do some initialization here \n \xa0\xa0\xa0\xa0\xa0 axis1=sim.getObjectHandle( \'MTB_axis1\' ) \n \xa0\xa0\xa0\xa0\xa0 axis1=sim.getObjectHandle( \'MTB_axis1\' ) \n \xa0\xa0\xa0\xa0\xa0 axis3=sim.getObjectHandle( \'MTB_axis3\' ) \n \xa0\xa0\xa0\xa0\xa0 axis4=sim.getObjectHandle( \'MTB_axis4\' ) \n \xa0\xa0\xa0\xa0\xa0 suctionPad=sim.getObjectHandle( \'suctionPad\' )\xa0\xa0\xa0\xa0  \n \xa0\xa0\xa0\xa0\xa0 rotation1 = 0 \n \xa0\xa0\xa0\xa0\xa0 distance3 = 0 \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0 deg =  math.pi /180 \n \xa0\xa0\xa0\xa0\xa0 --sim.sJointTargetVelocity(joint,5.5) \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0 \n end \n \xa0 \n function   sysCall_actuation() \n \xa0 calibration = 0.0042 \n \xa0 message,auxiliaryData=sim.getSimulatorMessage() \n \xa0 if   (message==sim.message_keypress)  then \n \xa0\xa0\xa0\xa0\xa0\xa0 print (auxiliaryData[1]) --key \n \xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]== string.byte ( \' \' ))  then \n \xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==97)  then --a \n \xa0\xa0\xa0\xa0\xa0\xa0 rotation1 = rotation1 + 5*deg \n \xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis1, rotation1) \n \xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==100)  then   --d \n \xa0\xa0\xa0\xa0\xa0\xa0 rotation1 = rotation1 - 5*deg \n \xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis1, rotation1) \n \xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==119)  then   --s \n \xa0\xa0\xa0\xa0\xa0\xa0 distance3 = distance3 + 0.01 + calibration \n \xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis3, distance3) \n \xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==115)  then   --w \n \xa0\xa0\xa0\xa0\xa0\xa0 distance3 = distance3 - 0.01 - calibration \n \xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis3, distance3) \n \xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==112)  then   --p activate the suction pad \n sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad), \'active\' , \'true\' ) \n \xa0\xa0\xa0\xa0\xa0\xa0 end   -- if p \n \xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==113)  then   --q deactivate the suction pad \n sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad), \'active\' , \'false\' ) \n \xa0\xa0\xa0\xa0\xa0\xa0 end   -- if q \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0 end \xa0\xa0\xa0 \n \xa0 \n \xa0 \n end \n function   sysCall_sensing() \n \xa0\xa0\xa0\xa0 -- put your sensing code here \n end \n \xa0 \n function   sysCall_cleanup() \n \xa0\xa0\xa0\xa0 -- do some clean-up here \n end \n \xa0 \n -- See the user manual or the available code snippets for additional callback functions and details \n \n \n \n \n \n \n \n 吸盤程式 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n \n \n \n function   sysCall_init()  \n \xa0\xa0\xa0\xa0 s=sim.getObjectHandle( \'suctionPadSensor\' ) \n \xa0\xa0\xa0\xa0 l=sim.getObjectHandle( \'suctionPadLoopClosureDummy1\' ) \n \xa0\xa0\xa0\xa0 l2=sim.getObjectHandle( \'suctionPadLoopClosureDummy2\' ) \n \xa0\xa0\xa0\xa0 b=sim.getObjectHandle( \'suctionPad\' ) \n \xa0\xa0\xa0\xa0 suctionPadLink=sim.getObjectHandle( \'suctionPadLink\' ) \n \xa0 \n \xa0\xa0\xa0\xa0 infiniteStrength=sim.getScriptSimulationParameter(sim.handle_self, \'infiniteStrength\' ) \n \xa0\xa0\xa0\xa0 maxPullForce=sim.getScriptSimulationParameter(sim.handle_self, \'maxPullForce\' ) \n \xa0\xa0\xa0\xa0 maxShearForce=sim.getScriptSimulationParameter(sim.handle_self, \'maxShearForce\' ) \n \xa0\xa0\xa0\xa0 maxPeelTorque=sim.getScriptSimulationParameter(sim.handle_self, \'maxPeelTorque\' ) \n \xa0 \n \xa0\xa0\xa0\xa0 sim.setLinkDummy(l,-1) \n \xa0\xa0\xa0\xa0 sim.setObjectParent(l,b, true ) \n \xa0\xa0\xa0\xa0 m=sim.getObjectMatrix(l2,-1) \n \xa0\xa0\xa0\xa0 sim.setObjectMatrix(l,-1,m) \n end \n \xa0 \n function   sysCall_cleanup()  \n \xa0\xa0\xa0\xa0 sim.setLinkDummy(l,-1) \n \xa0\xa0\xa0\xa0 sim.setObjectParent(l,b, true ) \n \xa0\xa0\xa0\xa0 m=sim.getObjectMatrix(l2,-1) \n \xa0\xa0\xa0\xa0 sim.setObjectMatrix(l,-1,m) \n end \n \xa0 \n function   sysCall_sensing()  \n \xa0\xa0\xa0\xa0 parent=sim.getObjectParent(l) \n \xa0\xa0\xa0\xa0 if   (sim.getScriptSimulationParameter(sim.handle_self, \'active\' )== false )  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (parent~=b)  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setLinkDummy(l,-1) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setObjectParent(l,b, true ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 m=sim.getObjectMatrix(l2,-1) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setObjectMatrix(l,-1,m) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 else \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (parent==b)  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- Here we want to detect a respondable shape, and then connect to it with a force sensor (via a loop closure dummy dummy link) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- However most respondable shapes are set to "non-detectable", so "sim.readProximitySensor" or similar will not work. \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- But "sim.checkProximitySensor" or similar will work (they don\'t check the "detectable" flags), but we have to go through all shape objects! \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 index=0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 while   true   do \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 shape=sim.getObjects(index,sim.object_shape_type) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (shape==-1)  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 break \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (shape~=b)  and   (sim.getObjectInt32Parameter(shape,sim.shapeintparam_respondable)~=0)  and   (sim.checkProximitySensor(s,shape)==1)  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- Ok, we found a respondable shape that was detected \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- We connect to that shape: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- Make sure the two dummies are initially coincident: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setObjectParent(l,b, true ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 m=sim.getObjectMatrix(l2,-1) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setObjectMatrix(l,-1,m) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- Do the connection: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setObjectParent(l,shape, true ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setLinkDummy(l,l2) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 break \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 index=index+1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- Here we have an object attached \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (infiniteStrength== false )  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- We might have to conditionally beak it apart! \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result,force,torque=sim.readForceSensor(suctionPadLink)  -- Here we read the median value out of 5 values (check the force sensor prop. dialog) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (result>0)  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 breakIt= false \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (force[3]>maxPullForce)  then   breakIt= true   end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sf= math.sqrt (force[1]*force[1]+force[2]*force[2]) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (sf>maxShearForce)  then   breakIt= true   end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (torque[1]>maxPeelTorque)  then   breakIt= true   end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (torque[2]>maxPeelTorque)  then   breakIt= true   end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (breakIt)  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- We break the link: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setLinkDummy(l,-1) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setObjectParent(l,b, true ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 m=sim.getObjectMatrix(l2,-1) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setObjectMatrix(l,-1,m) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 end \n end \n \n \n \n \n \n \n \n \n \n 教學影片: \n 如何在cippeliasim裡的MTB_robot安裝吸盤。 \n W16_t.7z \n \n MTB_robot add IK \n 使用老師的逆運動學函式求出終點位置的位移，使MTB_robot在coppeliasim裡可以順利達到老師要求的位置 \n W16_exam.7z \xa0error版本 \n W16_exam.7z \n loop迴圈影片: \n 因為迴圈做不出來，發現到46號網站的內容，找出wait問題點後的操作狀態 \n 參考40823246 \n \n \n 正確位置的影片(鍵盤) \n \n 錯誤位置的影片，但是有求出a1與a2。 \n \n 老師的程式 \n 修改後的程式 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n \n \n \n -- The decimal point of number x is rounded to the nth place \n function   round(x, n) \n \xa0\xa0\xa0\xa0 n =  math.pow (10, n  or   0) \n \xa0\xa0\xa0\xa0 x = x * n \n \xa0\xa0\xa0\xa0 if   x >= 0  then   x =  math.floor (x + 0.5)  else   x =  math.ceil (x - 0.5)  end \n \xa0\xa0\xa0\xa0 return   x / n \n end \n \xa0 \xa0 \n -- radian to degree \n deg = 180/ math.pi \n -- link 1 length \n a1 =0.467 \n -- link 2 length \n a2 =0.4 \n -- derivated based upon https://www.youtube.com/watch?v=IKOGwoJ2HLk&t=311s \n function   ik(x, y) \n \xa0\xa0\xa0\xa0 -- (x, y) need to be located inside the circle with radius a1+a2 \n \xa0\xa0\xa0\xa0 if   (x^2 + y^2) <= (a1+ a2)^2  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 q2 =  math.acos ((x^2+y^2-a1^2-a2^2)/(2*a1*a2)) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 q1 =  math.atan2 (y, x) -  math.atan2 ((a2* math.sin (q2)), (a1+a2* math.cos (q2))) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   {round(q1*deg, 4), round(q2*deg, 4)} \n \xa0\xa0\xa0\xa0 else \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "Over range!" ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- end the script execution \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 os.exit () \n \xa0\xa0\xa0\xa0 end \n end \n \xa0 \xa0 \n theta = ik(-0.3, -0.55) \n \xa0 \xa0 \n print (theta[1], theta[2]) \n \n \n \n \n \n \n \n lua 編譯網站: \n \n 目前吸盤無法放下，只能跟著連桿移動 \n 以下是參考 40823246 的remote api 來達成的結果。 \n \n W16_exam \n \n python 程式 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n 84 \n 85 \n 86 \n 87 \n 88 \n 89 \n 90 \n \n \n \n import   sim as vrep \n import   math \n import   random \n import   time \n import   keyboard \n \xa0 \xa0 \n \xa0 \xa0 \n print   ( \'Start\' ) \n \xa0 \xa0 \n # Close eventual old connections \n vrep.simxFinish( - 1 ) \n # Connect to V-REP remote server \n clientID  =   vrep.simxStart( \'127.0.0.1\' ,  19997 ,  True ,  True ,  5000 ,  5 ) \n \xa0 \xa0 \n if   clientID ! =   - 1 : \n \xa0\xa0\xa0\xa0 print   ( \'Connected to remote API server\' ) \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 res  =   vrep.simxAddStatusbarMessage( \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 clientID,  "40823152" , \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simx_opmode_oneshot) \n \xa0\xa0\xa0\xa0 if   res  not   in   (vrep.simx_return_ok, vrep.simx_return_novalue_flag): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "Could not add a message to the status bar." ) \n \xa0 \xa0 \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 opmode  =   vrep.simx_opmode_oneshot_wait \n \xa0\xa0\xa0\xa0 angle1 = math.pi / 180 \n \xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 # radian to degree \n \xa0\xa0\xa0\xa0 deg  =   180 / math.pi \n \xa0\xa0\xa0\xa0 # link 1 length \n \xa0\xa0\xa0\xa0 a1  =   0.468 \n \xa0\xa0\xa0\xa0 # link 2 length \n \xa0\xa0\xa0\xa0 a2  =   0.4 \n \xa0\xa0\xa0\xa0 # derivated based up https://www.youtube.com/watch?v=IKOGwoJ2HLk&t=311s \n \xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 def   ik(x, y): \n \xa0\xa0\xa0\xa0 # (x, y)\xa0 need to be located inside the circle with radius a1+a2 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (x * * 2   +   y * * 2 ) < =   (a1 +   a2) * * 2 : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 q2  =   math.acos((x * * 2 + y * * 2 - a1 * * 2 - a2 * * 2 ) / ( 2 * a1 * a2)) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 q1  =   math.atan2(y, x)  -   math.atan2((a2 * math.sin(q2)), (a1 + a2 * math.cos(q2))) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # The decimal point of number is rounded to the 4th place \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   [ round (q1 * deg,  4 ),  round (q2 * deg,  4 )] \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "Over range!" ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # end the script execution \n \xa0 \n \xa0 \xa0 \n \xa0\xa0\xa0\xa0 theta  =   ik( 0.2 ,  0.7 ) \n \xa0 \xa0 \n \xa0\xa0\xa0\xa0 print (theta[ 0 ], theta[ 1 ]) \n \xa0 \n \xa0 \n \xa0\xa0\xa0\xa0 ret,axis1 = vrep.simxGetObjectHandle(clientID, "MTB_axis1" ,opmode) \n \xa0\xa0\xa0\xa0 ret,axis2 = vrep.simxGetObjectHandle(clientID, "MTB_axis2" ,opmode) \n \xa0\xa0\xa0\xa0 ret,axis3 = vrep.simxGetObjectHandle(clientID, "MTB_axis3" ,opmode) \n \xa0\xa0\xa0\xa0 ret,suctionPad = vrep.simxGetObjectHandle(clientID, "suctionPad" ,opmode) \n \xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID,axis1,theta[ 0 ] * angle1,opmode) \n \xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID,axis2,theta[ 1 ] * angle1,opmode) \n \xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 time.sleep( 0.5 ) \n \xa0\xa0\xa0\xa0 while   True : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointPosition(clientID,axis3, 0.001 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 0.5 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 theta  =   ik( 0.2 ,  0.7 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 0.5 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointPosition(clientID,axis1,theta[ 0 ] * angle1,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointPosition(clientID,axis2,theta[ 1 ] * angle1,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 2 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetIntegerSignal(clientID, "suctionPad" ,  0 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 0.5 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointPosition(clientID,axis3, - 0.001 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 0.5 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetIntegerSignal(clientID, "suctionPad" ,  0 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 0.5 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointPosition(clientID,axis3, 0.001 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 0.5 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 theta  =   ik( - 0.3 ,  - 0.55 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointPosition(clientID,axis1,theta[ 0 ] * angle1,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointPosition(clientID,axis2,theta[ 1 ] * angle1,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 2 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetIntegerSignal(clientID, "suctionPad" ,  1 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 0.5 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointPosition(clientID,axis3, - 0.001 ,opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 0.5 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointPosition(clientID,axis3, 0.002 ,opmode) \n \xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n else : \n \xa0\xa0\xa0\xa0 print   ( \'Failed connecting to remote API server\' ) \n \xa0\xa0\xa0\xa0 print   ( \'End\' ) \n \n \n \n \n \n \n \n MTB_robo use require \n 將2到4的步驟新增require操作MTB_robot，並簡單介紹使用方法 \n W16_exam.7z \n \n \n 老師的leo', 'tags': '', 'url': '40823152.html'}, {'title': 'W18', 'text': '小組產品:籃球機 目標:把stage2-ag12的籃球機加入記分功能，籃框左右移動，fanuc_m710ic_50手臂投球，與最後才加的Mtb_robot取放球。 策略: 我們一次往3種方向去研究，不會使大家都研究同一項，結果最後還無法完成。因為只要有一項完成，我們的籃球機就有成果，且先完成的還能支援組員，使團隊更有效率。 工作分配:1人籃球框移動程式，1人畫圖，2人感測器，2人機械手臂組裝，2人機械手臂控制。 困難點: 時間與技術的不足，fanuc_m710ic_50手臂無法有效地做出投球的動作，目前只能簡單轉動單一軸的控制，理想狀態是:取到球後手臂做出投球一半的動作時，關閉氣壓缸，使球產生速度投進籃框裡。 \n \n \n 完成品: \n \n \n \n \n \n', 'tags': '', 'url': 'W18.html'}, {'title': '1.Basketball machine senser', 'text': '\n senser file link \n \n \n 這是紅球的內部狀況 \n \n 裡面放一顆較小的綠球，因為紅球太大顆會導致感測器失靈，所以讓感測器去感測綠球就不會有這個問題 \n \n 感測器放了四根，呈現八角形讓感測器可以比較容易感測球 \n \n 當綠球觸碰到res、res0、res1抑或是res2 \n 那麼就會顯示1分 \n \n 這段程式是為了在製作感測器時能夠方便檢測，所以讓球重生再籃框上的位置 \n \n 畫面看起來會像這樣 \n \n', 'tags': '', 'url': '1.Basketball machine senser.html'}, {'title': '2.Basketball machine Slider', 'text': '\n \n 圖檔: \n \n slide file link \n \n \n 當a==10時 會執行向左移動 直到d<=-0.5 \n d<=-0.5時，會執行a=0，b=10 \n \n 當b==10時 會執行向右移動 直到d>=0.5 \n d>=0.5時，會執行a=10，b=0 \n \n a，b變數是用來判斷滑塊要向左或向右移動 \n d是用來判斷座標點 \n distance是用來給位移量 \n \n \n', 'tags': '', 'url': '2.Basketball machine Slider.html'}, {'title': '3.Basketball machine by (MTB_Robot)', 'text': '使用老師的ik程式，使Mtb_robot放球到最終的位置(x=1.002,y=0) 但是把MTB_robot放到籃球機的場景裡，不能直接在程式裡打ik(1.002,0)，因為MTB_robot沒有在座標原點上，所以要減掉MTB_robot的座標(0.7496,-2.3502)，得出(0.2506,2.3502)，才會移動到正確的座標。 \n \n \n 操作說明 \n \n 鍵盤操作 \n \n \n \n \n \n', 'tags': '', 'url': '3.Basketball machine by (MTB_Robot).html'}]};